
 MODULE main
 VAR
    step: 0..11;
    int_x: 0..9;
    int_k: 0..3;
    secret_in: 0..3;
    public_out: 0..3;

  ASSIGN

    -- L0:
    -- L0: x = 0
    -- L0: k = 0
    -- L0: if (k == 0)
    -- L1: {x := secret_input();}
    -- L2: else {x := x + x;}
    -- L3: k := k + 1;
    -- L4: public_output = (x % k);
    -- L5: while (k < 3) {
    -- L6: if (k == 0) {
    -- L7:  x := secret_input();}
    -- L8: else {x := x + x;}
    -- L9: k := k + 1;
    -- L10: public_output(x % k);
    -- L11: END
  init(step):= 0;
  next(step):=
    case
      ((step=0) & (int_k=0)): {1};
      ((step=0) & !(int_k=0)): {2};
      (step=1): {3};
      (step=2): {3};
      (step=3): {4};
      (step=4): {5};
      ((step=5) & (int_k<3)): {6};
      ((step=5) & !(int_k<3)): {11};
      ((step=6) & (int_k=0)): {7};
      ((step=6) & !(int_k=0)): {8};
      (step=7): {9};
      (step=8): {9};
      (step=9): {10};
      (step=10): {5};
      TRUE: step;
    esac;

  init(int_x) := 0;
  next(int_x) :=
    case
      ((int_x+int_x)>9): 9;
      (step=1) : secret_in;
      (step=2) : int_x+int_x;
      (step=7) : secret_in;
      (step=8) : int_x+int_x;
      TRUE: int_x;
    esac;

  init(int_k) := 0;
  next(int_k) :=
    case
      (int_k=3): 3;
      (step=3) : int_k+1;
      (step=9) : int_k+1;
      TRUE: int_k;
    esac;

  init(public_out) := 0;
  next(public_out) :=
    case
      ((step=4)& !(int_k=0)): int_x mod int_k;
      ((step=10)& !(int_k=0)): int_x mod int_k;
      TRUE: public_out;
    esac;

  init(secret_in) := 1;
  next(secret_in) := secret_in;

  DEFINE
  BEGIN := (step=0);
  halt := (step=11);
